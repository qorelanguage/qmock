#!/usr/bin/env qore
# -*- mode: qore; indent-tabs-mode: nil -*-

module QMock {
    version = "1.0";
    desc = "QMock module";
    author = "Qore Technologies";
    url = "";
    license = "";

    init = sub () {
    };

    del = sub () {
    };
}

%new-style
%require-types
%enable-all-warnings
%strict-args

public namespace QMock {

    public class QMockProxy {
    # private members
        private {
            list<code> rules;
            auto return_value;
            list<QMockProxy> others;
        }

    #public methods
        #! TODO doc
        public constructor() {
            self.rules = new list<code>();
            self.return_value = NOTHING;
            self.others = new list<QMockProxy>();
        }

        #! TODO doc
        public nothing addEvaluation(QMockProxy obj) {
            push self.others, obj;
        }

        #! TODO doc
        public auto eval(*list argv) {
            bool match = True;
            foreach code rule in (self.rules) {
                if (!rule(argv)) {
                    match = False;
                    break;
                }
            }
            if (match) {
                if (self.return_value instanceof code) {
                    return call_function_args(self.return_value, argv);
                }
                return self.return_value;
            }

            foreach QMockProxy obj in (self.others) {
                try {
                    return obj.eval(argv);
                } catch (ex) {
                    switch (ex.err) {
                        case "QMOCK-PROXY-EVAL-FAIL":
                            # ignore, try next one
                        break;
                        default:
                            rethrow;
                    }
                }
            }

            throw "QMOCK-PROXY-EVAL-FAIL";
        }

        # --------------

        #! TODO doc
        public QMockProxy argsEq(*list expected_argv) {
            push self.rules, bool sub(*list argv) {
                return expected_argv === argv;
            };
            return self;
        }

        #! TODO doc
        public QMockProxy argEq(int arg_no, auto expected) {
            push self.rules, bool sub(*list argv) {
                if (!exists argv[arg_no]) {
                    return False;
                }
                return argv[arg_no] === expected;
            };
            return self;
        }

        #! TODO doc
        public QMockProxy argRegex(int arg_no, string pattern, int options = 0) {
            push self.rules, bool sub(*list argv) {
                if (!exists argv[arg_no]) {
                    return False;
                }
                return argv[arg_no].regex(pattern, options);
            };
            return self;
        }

        #! TODO doc
        public nothing return_value(auto return_value) {
            self.return_value = return_value;
        }

        #! TODO doc
        public nothing throw_exception(auto err, auto desc = NOTHING, auto arg = NOTHING) {
            self.return_value = sub() { throw err, desc, arg; };
        }
    }

    #! TODO doc
    public hashdecl QMockSettings {
        bool is_strict = STRICT;
    }

    #! TODO doc
    public class QMock {

    # public constants
        public {
            const STRICT = True;
            const VAGUE = False;
        }

    # public members
        public {
            list _mock_calls;
            hash _mock_calls_with_args;
        }

    # private members
        private {
            hash<string, auto> mocked_methods; # hash indexed by method name with value of either 'code' or 'QMockProxy'
            hash<QMockSettings> settings;      # settings of the QMock object
        }

    #public methods
        #! Creates instance of QMock.
        /* Note: Use only default ctor for QMock, so no dependencies are inherited.
         */
        public constructor() {
            self.mocked_methods = new hash<string, auto>();
            self.settings = new hash<QMockSettings>();
            self._mock_calls = list();
            self._mock_calls_with_args = hash();
        }

        #! Updates settings of the instance. See @QMockSettings
        /* @param settings      New settings that should be used.
         */
        public nothing _mock_settings(hash settings) {
            self._mock_settings(cast<hash<QMockSettings>>(settings));
        }

        #! Updates settings of the instance. See @QMockSettings
        /* @param settings      New settings that should be used.
         */
        public nothing _mock_settings(hash<QMockSettings> settings) {
            self.settings = settings;
        }

        #! Mocks @p method_names method(s) with passed @method_code code.
        /* @param method_names      One or more moethod names that should be mocked
           @param method_code       Code with which method(s) should be mocked
           @throws "INVALID-ARGUMENT" in case the method(s) is already mocked.

           Note: In case an exception is raised, no method is mocked.
         */
        public nothing _mock(softlist<string> method_names, code method_code) {
            foreach string method_name in (method_names) {
                if (exists self.mocked_methods{method_name}) {
                    throw "INVALID-ARGUMENT", sprintf("Method %n is already mocked", method_name);
                }
            }

            foreach string method_name in (method_names) {
                self.mocked_methods{method_name} = method_code;
            }
        }

        #! TODO doc
        public QMockProxy _mock(softlist<string> method_names) {
            auto obj = new QMockProxy();
            foreach string method_name in (method_names) {
                if (exists self.mocked_methods{method_name}) {
                    auto mth = self.mocked_methods{method_name};
                    if (mth instanceof QMockProxy) {
                        mth.addEvaluation(obj);
                    } else {
                        throw "INVALID-ARGUMENT", sprintf("Method %n is already mocked", method_name);
                    }
                } else {
                    self.mocked_methods{method_name} = obj;
                }
            }
            return obj;
        }

        #! TODO doc
        public int _assert_called(string method_name) {
            return elements select self._mock_calls, $1 === method_name;
        }

        #! TODO doc
        public bool _assert_called_once(string method_name) {
            return 1 === self._assert_called(method_name);
        }

        #! TODO doc
        public int _assert_called_with_args(string method_name, list args) {
            int amount_of_calls = 0;
            foreach list called_args in (self._mock_calls_with_args{method_name}) {
                amount_of_calls += (called_args === args);
            }
            return amount_of_calls;
        }

        #! TODO doc
        public bool _assert_called_once_with_args(string method_name, list args) {
            return 1 === self._assert_called_with_args(method_name, args);
        }

        #! TODO doc
        synchronized public auto methodGate(string method_name) {

            # look for mocked code
            auto mth = self.mocked_methods{method_name} ?? self.mocked_methods{"*"};

            if (mth === NOTHING && self.settings.is_strict === QMock::STRICT) {
                throw "INVALID-ARGUMENT", sprintf("Method %n is not mocked", method_name);
            }

            # track call
            push _mock_calls, method_name;

            # track call with arguments
            if (!exists _mock_calls_with_args{method_name}) {
                _mock_calls_with_args{method_name} = ();
            }
            push _mock_calls_with_args{method_name}, argv;

            # not mocked
            if (mth === NOTHING) {
                return NOTHING;
            }

            # call mocked code
            if (mth instanceof QMockProxy) {
                try {
                    return mth.eval(argv);
                } catch (ex) {
                    switch (ex.err) {
                        case "QMOCK-PROXY-EVAL-FAIL":
                            if (self.settings.is_strict === QMock::STRICT) {
                                throw "INVALID-ARGUMENT", sprintf("Mocked method %n evaluation failed", method_name);
                            }
                            return NOTHING;
                        default:
                            rethrow;
                    }
                }
            }

            return call_function_args(mth, argv);
        }
    }

} # namespace
